{"version":3,"file":"mapp-ui-common-tablefilter.mjs","sources":["../../../../projects/mapp-ui/common/tablefilter/src/table-filters.ts","../../../../projects/mapp-ui/common/tablefilter/src/mapp-ui-common-tablefilter.ts"],"sourcesContent":["import { MatTableDataSource } from '@angular/material/table';\r\nimport { DateTime, Interval } from 'luxon';\r\n\r\n/**\r\n * This file holds helpers for creating filters for material data table\r\n */\r\n\r\n/**\r\n * Configuration parameters for a given filter instance. Use as follows:\r\n * name: name of the column to be filtered. needs to match the column name used in MatTableDataSource\r\n * matcher: the matcher to be used for filtering. Currently supported\r\n *   - substringMatch: match on a substring level\r\n *   - exactMatch: exact match, supports string and numbers\r\n *   - dateMatch: match dates on a day-based granularity (time is ignored)\r\n *   - dateRangeMatch: match against a date range\r\n *   - propertyMatch: matching for nested object structures\r\n * paths: this is used by propertyMatch. specify the lookup path of one or multiple properties to filter\r\n * Example: paths: ['owner.firstName', 'owner.lastName']\r\n * for arrays specify the index position also in dot notation: paths: ['events.0.type']\r\n */\r\nexport interface FilterConfig {\r\n  [name: string]: { matcher: string, paths?: string[] };\r\n}\r\n\r\ninterface FilterCollection {\r\n  [name: string]: (filterTerm: string, dataVal: any, paths?: string[]) => boolean;\r\n}\r\n\r\nconst filterCollection: FilterCollection = {\r\n  substringMatch: (filterTerm: string, dataVal: string) => {\r\n    if (filterTerm && dataVal) {\r\n      return dataVal.toLowerCase().includes(filterTerm.toLowerCase());\r\n    } else {\r\n      return !(filterTerm && !dataVal);\r\n    }\r\n  },\r\n  exactMatch: (filterTerm: string, dataVal: string | number) => {\r\n    if (filterTerm && dataVal) {\r\n      if (typeof dataVal === 'string') {\r\n        return dataVal.toLowerCase() === filterTerm.toLowerCase();\r\n      } else {\r\n        return +filterTerm === dataVal;\r\n      }\r\n    } else {\r\n      return !(filterTerm && !dataVal);\r\n    }\r\n  },\r\n  dateMatch: (filterTerm: string, dataVal: string | number) => {\r\n    if (filterTerm && dataVal) {\r\n      if (typeof dataVal === 'string') {\r\n        return DateTime.fromISO(filterTerm).hasSame(DateTime.fromISO(dataVal), 'day');\r\n      } else {\r\n        return DateTime.fromISO(filterTerm).hasSame(DateTime.fromMillis(dataVal), 'day');\r\n      }\r\n\r\n    } else {\r\n      return !(filterTerm && !dataVal);\r\n    }\r\n  },\r\n\r\n  dateRangeMatch: (\r\n      filterTerm: string,\r\n      dataVal: string | number): boolean => {\r\n    if (!filterTerm || !dataVal) {\r\n      return !(filterTerm && !dataVal);\r\n    }\r\n\r\n    const dr = Interval.fromISO(filterTerm);\r\n    if (!dr.start || !dr.end) {\r\n      return !(filterTerm && !dataVal);\r\n    }\r\n    // create adjusted interval with +1 day end, as end date is exclusive in the interval\r\n    const dateRange = Interval.fromDateTimes(dr.start, dr.end.plus({ days: 1 }));\r\n    const dt = typeof dataVal === 'string' ? DateTime.fromISO(dataVal) : DateTime.fromMillis(dataVal);\r\n    return dateRange.contains(dt);\r\n  },\r\n\r\n  propertyMatch: (\r\n      filterTerm: string,\r\n      data: any,\r\n      paths?: string[]) => {\r\n    let combinedVal = '';\r\n\r\n    // search json value by path for example \"owner.firstName\"\r\n    const resolveJsonPropValue = (path: string, obj: any) => {\r\n      return path.split('.').reduce((prev, current) => {\r\n        return prev ? prev[current] : null;\r\n      }, obj || self);\r\n    };\r\n\r\n    paths?.forEach(path => {\r\n      const resolvedVal = resolveJsonPropValue(path, data);\r\n      if (resolvedVal) {\r\n        combinedVal += resolvedVal + ' ';\r\n      }\r\n    });\r\n\r\n    if (filterTerm && combinedVal) {\r\n      return combinedVal.toLowerCase().includes(filterTerm.toLowerCase());\r\n    } else {\r\n      return !(filterTerm && !combinedVal);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Registers a filterPredicate function on the MatTableDataSource, configured by the given filtersConfig\r\n * @param filtersConfig filter configuration to be used for this table\r\n * @param dataSource the data source where the filters should be applied\r\n */\r\nexport function setUpFilterPredicate(filtersConfig: FilterConfig, dataSource: MatTableDataSource<any>): void {\r\n\r\n  dataSource.filterPredicate = (data, filterString) => {\r\n    const filters = JSON.parse(filterString);\r\n\r\n    const filterResult = Object.keys(filters).map(key => {\r\n      const filterTerm = filters[key];\r\n      const dataValue: string = data[key];\r\n      const currentFilter = filterCollection[filtersConfig[key].matcher];\r\n      const currentPaths = filtersConfig[key].paths;\r\n\r\n      if (currentFilter) {\r\n        if (currentPaths) {\r\n          return currentFilter(filterTerm, data, currentPaths);\r\n        } else {\r\n          return currentFilter(filterTerm, dataValue);\r\n        }\r\n      } else {\r\n        return true;\r\n      }\r\n\r\n    });\r\n\r\n    const result = filterResult.reduce((prev, curr) => prev && curr);\r\n    return result;\r\n  };\r\n\r\n}\r\n\r\ntype TableDataValue = string | number | boolean;\r\ntype TableData = Record<string, TableDataValue>;\r\n\r\n/**\r\n * Default implementation for the sortingDataAccessor to be passed to a MatTableDataSource.\r\n * All data values are expected to be of type string | number | boolean.\r\n * If your table data has different value types, use a custom implementation for sortingDataAccessor.\r\n */\r\nexport function defaultSortingDataAccessor<T>(\r\n    data: T,\r\n    sortHeaderId: string): string | number {\r\n  const sortValue = (data as TableData)[sortHeaderId];\r\n  if (typeof sortValue === 'string') {\r\n    return sortValue.toLowerCase();\r\n  } else if (typeof sortValue === 'boolean') {\r\n    return sortValue ? 1 : 0;\r\n  } else {\r\n    return sortValue;\r\n  }\r\n\r\n}\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public_api';\n"],"names":[],"mappings":"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"}